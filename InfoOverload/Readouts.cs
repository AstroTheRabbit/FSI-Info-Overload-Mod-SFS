using System;
using Newtonsoft.Json;
using UnityEngine;
using SFS.Builds;
using SFS.Parts;
using SFS.World;
using static SFS.Base;
using static SFS.Builds.BuildGrid;
using SFS.Parts.Modules;
using SFS.Translations;
using System.Linq;
using System.Collections.Generic;
using System.Net.NetworkInformation;
using System.Text;

namespace InfoOverload
{
    [Serializable]
    public class Readout : Settings
    {
        [JsonIgnore]
        public string name;
        [JsonProperty("visible")]
        public bool displayReadout = true;
        public delegate (bool, string) UpdateInfo(Readout readout);
        [JsonIgnore]
        public UpdateInfo updater;
        [JsonIgnore]
        public Dictionary<string, object> vars = new Dictionary<string, object>();

        public Readout(string name, UpdateInfo func, Dictionary<string, object> settings)
        {
            this.name = name;
            this.updater = func;
            this.settings = settings;
            
        }
        public void CreateVariable<T>(string varName, T defaultValue)
        {
            if (!vars.ContainsKey(varName))
                vars.Add(varName, defaultValue);
        }

        public override void LoadOtherSettings(Settings input)
        {
            if (input is Readout readout)
                this.displayReadout = readout.displayReadout;
        }
    }
    public class Readouts
    {
        public static Readout RocketInfo() => new Readout
        (
            "Rocket Info",
            delegate(Readout readout)
            {
                string info = "Rocket Info:";
                if (PlayerController.main.player.Value is Rocket rocket)
                {
                    Location location = rocket.location.Value;
                    float thrust = rocket.partHolder.GetModules<EngineModule>().Sum((EngineModule a) => a.thrust.Value * a.throttle_Out.Value) + rocket.partHolder.GetModules<BoosterModule>().Sum((BoosterModule b) => b.thrustVector.Value.magnitude * b.throttle_Out.Value);
                    info += "\n• Name: " + (rocket.rocketName != "" ? rocket.rocketName : Loc.main.Default_Rocket_Name);
                    info += "\n• Local thrust/weight: " + (thrust / (rocket.location.Value.planet.GetGravity(location.Radius) * rocket.mass.GetMass() / 9.8)).ToString(2, true);
                    info += "\n• Global rotation: " + NormaliseAngle(rocket.rb2d.rotation).ToString(4, true)+"°";
                    info += "\n• Angular velocity: " + rocket.rb2d.angularVelocity.ToString(4, true)+"°/s";
                    info += "\n• Other height" + ((!(location.TerrainHeight < 2000.0) && !(location.Height < 500.0)) ? (" (Terrain): " + location.TerrainHeight.ToDistanceString(true)) : (": " + location.Height.ToDistanceString(true)));
                    return (true, info);
                }
                else
                    return (false, info);

                float NormaliseAngle(float a)
                {
                    while (a < 0)    { a += 360; }
                    while (a >= 360) { a -= 360; }
                    return a;
                }
            },
            new Dictionary<string, object>()
        );
        public static Readout BuildInfo() => new Readout
        (
            "Build Info",
            delegate(Readout readout)
            {
                string info = "Build Info:";
                Vector2 centerOfMass = Vector2.zero;
                if (BuildManager.main)
                {
                    if (BuildManager.main.buildGrid.activeGrid.partsHolder.parts.Count != 0)
                    {
                        float mass = 0f;
                        foreach (Part part in BuildManager.main.buildGrid.activeGrid.partsHolder.parts)
                        {
                            mass += part.mass.Value;
                            centerOfMass += (part.Position + part.centerOfMass.Value * part.orientation) * part.mass.Value;
                        }
                        centerOfMass /= mass;
                        info +=  "\n• CoM position: " + centerOfMass;
                        info += $"\n• Width: {ReadoutUtility.GetDimension(false).ToString(3, false)}m";
                        info += $"\n• Height: {ReadoutUtility.GetDimension(true).ToString(3, false)}m";
                        
                        // Vector2 position = Vector2.zero;
                        // Vector2 direction = Vector2.zero;
                        // float thrust = 0f;
                        // List<EngineModule> engines = BuildManager.main.buildGrid.activeGrid.partsHolder.GetModules<EngineModule>().ToList();
                        // List<BoosterModule> boosters = BuildManager.main.buildGrid.activeGrid.partsHolder.GetModules<BoosterModule>().ToList();

                        // foreach (EngineModule engine in engines)
                        // {
                        //     float gimbal = 0;
                        //     if (engine.hasGimbal && engine.Rb2d != null)
                        //         gimbal = (engine.gimbal.animationElements.First(ae => ae.type == MoveData.Type.RotationZ).transform.localEulerAngles.z) * Mathf.Deg2Rad;

                        //     // https://youtu.be/7j5yW5QDC2U?t=203
                        //     Vector2 mx = new Vector2(Mathf.Cos(gimbal), Mathf.Sin(gimbal));
                        //     Vector2 my = new Vector2(Mathf.Sin(gimbal), -Mathf.Cos(gimbal));
                        //     Vector2 thrustPosition = -(engine.thrustPosition.Value.x * mx) - (engine.thrustPosition.Value.y * my);
                        //     Vector2 thrustNormal = -(engine.thrustNormal.Value.x * mx) - (engine.thrustNormal.Value.y * my);

                        //     position += (Vector2)engine.transform.TransformPoint(thrustPosition) * engine.thrust.Value;
                        //     direction += (Vector2)engine.transform.TransformPoint(thrustPosition - thrustNormal) * engine.thrust.Value;
                        //     thrust += engine.thrust.Value;
                        // }

                        // foreach (BoosterModule booster in boosters)
                        // {
                        //     Vector2 thrustPosition = booster.thrustPosition.Value;
                        //     Vector2 thrustNormal = booster.thrustVector.Value;
                        //     position += (Vector2)booster.transform.TransformPoint(thrustPosition) * thrustNormal.magnitude;
                        //     direction += (Vector2)booster.transform.TransformPoint(thrustPosition - thrustNormal) * thrustNormal.magnitude;
                        //     thrust += thrustNormal.magnitude;
                        // }

                        // position /= thrust;
                        // direction /= thrust;

                        // info += "\n• CoT to CoM angle: " + SignedNormaliseAngle(Mathf.Rad2Deg * Vector2.SignedAngle(centerOfMass - position, position - direction));

                        return (true, info);
                    }
                }
                return (false, info);

                // float SignedNormaliseAngle(float a)
                // {
                //     while (a < -180) { a += 360; }
                //     while (a >= 180) { a -= 360; }
                //     return a;
                // }
            },
            new Dictionary<string, object>()
        );
        public static Readout PlanetInfo() => new Readout
        (
            "Planet Info",
            delegate(Readout readout)
            {
                string info = "Planet Info:";
                if (PlayerController.main.player.Value is Rocket rocket)
                {
                    Location location = rocket.location.Value;
                    info += "\n• Name: " + location.planet.DisplayName;
                    info += "\n• Current gravity: " + location.planet.GetGravity(location.Radius).ToVelocityString(doubleDecimal: true);
                    info += "\n• Radius: " + location.planet.Radius.ToDistanceString();
                    info += "\n• Max terrain height: " + location.planet.maxTerrainHeight.ToDistanceString();
                    info += "\n• SoI radius: " + location.planet.SOI.ToDistanceString();
                    // info += "\n• " + ((float)location.planet.mass).ToMassString(false);
                    return (true, info);
                }
                else
                    return (false, info);
            },
            new Dictionary<string, object>()
        );

        public static Readout SelectedPartsInfo() => new Readout(
            "Selected Parts Info",
            delegate(Readout readout)
            {
                // CHECKS
                
                if (!BuildManager.main)
                    return (false, null);
                var selected = BuildManager.main.buildGrid.GetSelectedParts();

                if (selected == null || selected.Length == 0) return (false, null);
                
                // CALCULATIONS
                
                double mass = 0;
                selected.ForEach(part => mass += part.mass.Value);

                double thrust = 0;
                foreach (var part in selected)
                {
                    var em = part.GetComponentInChildren<EngineModule>();
                    var bm = part.GetComponentInChildren<BoosterModule>();
                    if (em)
                        thrust += em.thrust.Value * part.orientation.orientation.Value.y;
                    if (bm)
                        thrust += bm.thrustVector.Value.magnitude * part.orientation.orientation.Value.y;
                }
                
                // DISPLAY
                
                var info = new StringBuilder();
                
                info.Append("Selected Parts Info:\n");
                info.Append($"• Width: {ReadoutUtility.GetDimension(false, selected).ToString(3, false)}m\n");
                info.Append($"• Height: {ReadoutUtility.GetDimension(true, selected).ToString(3, false)}m\n");
                info.Append($"• Part count: {selected.Length}\n");
                info.Append($"• Mass: {mass.ToString(3, false)}t");
                if (thrust > 0)
                {
                    info.Append($"\n• Thrust: {thrust.ToString(3, false)}t\n");
                    info.Append($"• TWR: {(thrust / mass).ToString(3, true)}");
                }

                return (true, info.ToString());
            },
            new Dictionary<string, object>()
        );
        
        public static Readout AtmoInfo() => new Readout
        (
            "Atmo Info",
            delegate(Readout readout)
            {
                string info = "Atmospheric Info:";
                if (PlayerController.main.player.Value is Rocket rocket)
                {
                    if (rocket.location.Value.planet.HasAtmospherePhysics)
                    {
                        info += "\n• Current density: " + rocket.location.Value.planet.GetAtmosphericDensity(rocket.location.Value.Height).ToString(6, false);
                        info += "\n• Height: " + rocket.location.Value.planet.data.atmospherePhysics.height.ToDistanceString();
                        if (!readout.GetSetting<bool>("Hide Parachute Info"))
                        {
                            info += "\n• Max parachute height: " + (rocket.location.Value.planet.data.atmospherePhysics.parachuteMultiplier * 2500).ToDistanceString();
                            info += "\n• Max parachute speed: " + (rocket.location.Value.planet.data.atmospherePhysics.parachuteMultiplier * 250).ToVelocityString();
                        }
                        // double minHeatingVelocity = rocket.location.Value.planet.data.atmospherePhysics.minHeatingVelocityMultiplier * worldBase.settings.difficulty.MinHeatVelocityMultiplier * 250;
                        // info += "\n• Min heating speed: " + minHeatingVelocity.ToVelocityString();
                        return (true, info);
                    }
                }
                return (false, info);
            },
            new Dictionary<string, object>()
            {
                {"Hide Parachute Info", false}
            }
        );
        public static Readout ActiveCheats() => new Readout
        (
            "Active Cheats",
            delegate(Readout readout)
            {
                string info = "Active Cheats:";
                info += worldBase.settings.cheats.infiniteBuildArea ? ("\n• " + Loc.main.Infinite_Build_Area_Name) : "";
                info += worldBase.settings.cheats.partClipping ? ("\n• " + Loc.main.Part_Clipping_Name) : "";
                info += worldBase.settings.cheats.infiniteFuel ? ("\n• " + Loc.main.Infinite_Fuel_Name) : "";
                info += worldBase.settings.cheats.noAtmosphericDrag ? ("\n• " + Loc.main.No_Atmospheric_Drag_Name) : "";
                info += worldBase.settings.cheats.unbreakableParts ? ("\n• " + Loc.main.No_Collision_Damage_Name) : "";
                info += worldBase.settings.cheats.noGravity ? ("\n• " + Loc.main.No_Gravity_Name) : "";
                info += worldBase.settings.cheats.noHeatDamage ? ("\n• " + Loc.main.No_Heat_Damage_Name) : "";
                info += worldBase.settings.cheats.noBurnMarks ? ("\n• " + Loc.main.No_Burn_Marks_Name) : "";
                return (info != "Active Cheats:", info);
            },
            new Dictionary<string, object>()
        );
        public static Readout MiscInfo() => new Readout
        (
            "Misc. Info",
            delegate(Readout readout)
            {
                float updateInterval = readout.GetSetting<float>("FPS Update Interval");
                readout.CreateVariable("frames", 0);
                readout.CreateVariable("currentInterval", 0f);
                readout.CreateVariable("elapsedTime", 0f);
                readout.CreateVariable("elapsedTimePhysics", 0f);
                readout.CreateVariable("fps", 0f);
                readout.CreateVariable("fpsPhysics", 0f);

                readout.vars["currentInterval"] = (float)readout.vars["currentInterval"] + Time.unscaledDeltaTime;
                readout.vars["elapsedTime"] = (float)readout.vars["elapsedTime"] + (1/Time.unscaledDeltaTime);
                readout.vars["elapsedTimePhysics"] = (float)readout.vars["elapsedTimePhysics"] + (1/Time.fixedUnscaledDeltaTime);
                readout.vars["frames"] = (int)readout.vars["frames"] + 1;
                if ((float)readout.vars["currentInterval"] >= updateInterval)
                {
                    readout.vars["fps"] = (float)readout.vars["elapsedTime"] / (int)readout.vars["frames"];
                    readout.vars["fpsPhysics"] = (float)readout.vars["elapsedTimePhysics"] / (int)readout.vars["frames"];
                    readout.vars["frames"] = 0;
                    readout.vars["elapsedTime"] = 0f;
                    readout.vars["elapsedTimePhysics"] = 0f;
                    readout.vars["currentInterval"] = 0f;
                }

                string info = "Misc. Info:";
                info += GameManager.main != null ? ("\n• No. rockets (L/T): " + GameManager.main.rockets.Count(r => r.physics.loader.Loaded) + "/" + GameManager.main.rockets.Count()) : "";
                info += "\n• FPS: " + ((float)readout.vars["fps"]).ToString(2, true);
                info += GameManager.main != null ? ("\n• Physics FPS: " + ((float)readout.vars["fpsPhysics"]).ToString(2, true)) : "";
                return (true, info);
            },
            new Dictionary<string, object>()
            {
                {"FPS Update Interval", 0.5f}
            }
        );
        public static Readout PartCount() => new Readout
        (
            "Part Count",
            delegate(Readout readout)
            {
                string info = "Part Counts:";
                PartHolder parts = null;
                if (BuildManager.main != null)
                     parts = BuildManager.main.buildGrid.activeGrid.partsHolder;
                else if (PlayerController.main.player.Value is Rocket rocket)
                    parts = rocket.partHolder;

                if (parts == null)
                    return (false, info);

                Dictionary<string, int> partCount = new Dictionary<string, int>();

                foreach (Part part in parts.parts)
                {
                    if (!partCount.ContainsKey(part.displayName.Field))
                        partCount.Add(part.displayName.Field, 0);
                    partCount[part.displayName.Field]++;
                }

                foreach (var part in (from p in partCount orderby p.Value descending select p))
                {
                    info += "\n• " + part.Key + ": " + part.Value;
                }
                
                return (partCount.Count > 0, info);
            },
            new Dictionary<string, object>()
        );
    }

    public static class ReadoutUtility
    {
        public static List<PartCollider> CreateBuildColliders(params Part[] parts)
        {
            List<PartCollider> buildColliders = new List<PartCollider>();
            for (int i = 0; i < parts.Length; i++)
            {
                PolygonData[] modules = parts[i].GetModules<PolygonData>();
                foreach (PolygonData polygonData in modules)
                {
                    if (polygonData.BuildCollider /* _IncludeInactive */)
                    {
                        PartCollider partCollider = new PartCollider
                        {
                            module = polygonData,
                            colliders = null
                        };
                        partCollider.UpdateColliders();
                        buildColliders.Add(partCollider);
                    }
                }
            }
            return buildColliders;
        }
        
        public static float GetDimension(bool height, Part[] parts = null)
        {
            float lowest = float.MaxValue;
            float highest = -float.MaxValue;

            foreach (var part in parts ?? BuildManager.main.buildGrid.activeGrid.partsHolder.parts.ToArray())
            {
                foreach (var partPoly in CreateBuildColliders(part)
                             .SelectMany((PartCollider col) => col.colliders))
                {
                    foreach (var vertice in partPoly.points)
                    {
                        var pos = height ? vertice.y : vertice.x;
                        
                        if (pos < lowest) lowest = pos;
                        if (pos > highest) highest = pos;
                    }
                }
                /*foreach (var data in part.GetModules<PolygonData>())
                {
                    var polygon = data.polygon;

                    foreach (var vertice in polygon.vertices)
                    {
                        var pos = height ? part.transform.TransformPoint(new Vector3(0, vertice.y, 0)).y : part.transform.TransformPoint(new Vector3(0, vertice.x, 0)).x;
                        
                        if (pos < lowest) lowest = pos;
                        if (pos > highest) highest = pos;
                    }
                }*/
            }
            
            return Mathf.Abs(highest - lowest);
        }      
    }
}